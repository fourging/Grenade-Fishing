# 物品系统架构详解

## 概述

物品系统是《逃离鸭科夫》的核心系统之一，负责管理游戏中的所有物品、属性、效果、背包等功能。该系统采用模块化设计，提供了灵活的物品创建、管理和交互机制，支持复杂的物品关系和动态行为。

## 系统架构

### 核心设计理念

物品系统基于以下几个核心设计理念：

1. **组件化设计**：每个物品由多个组件组成，包括基础属性、统计属性、效果、插槽等
2. **树形结构**：物品可以包含其他物品，形成树形结构，支持复杂的物品组合
3. **事件驱动**：通过事件系统实现物品状态变化的响应和处理
4. **动态扩展**：支持运行时添加新物品类型和修改物品属性
5. **数据驱动**：物品定义和行为主要由数据驱动，便于配置和修改

### 系统组件关系图

```
物品系统架构
├── ItemAssetsCollection (物品资产集合)
│   ├── 预制体管理
│   ├── 动态物品管理
│   └── 物品搜索
├── Item (物品核心)
│   ├── 基础属性 (TypeID, DisplayName, Value等)
│   ├── 堆叠系统 (StackCount, MaxStackCount)
│   ├── 重量系统 (UnitWeight, TotalWeight)
│   ├── 耐久度系统 (Durability, MaxDurability)
│   ├── 标签系统 (Tags)
│   ├── 变量系统 (Variables, Constants)
│   ├── 组件系统
│   │   ├── StatCollection (统计属性)
│   │   ├── SlotCollection (插槽集合)
│   │   ├── ModifierDescriptionCollection (修饰符集合)
│   │   ├── Inventory (背包)
│   │   └── Effect (效果)
│   └── 事件系统
├── Inventory (背包系统)
│   ├── 容量管理
│   ├── 物品存储
│   ├── 重量计算
│   └── 内容变化事件
├── Slot (插槽系统)
│   ├── 物品装备
│   ├── 连接管理
│   └── 事件通知
├── Stat (统计属性)
│   ├── 基础值管理
│   ├── 修饰符系统
│   └── 数值计算
├── Modifier (修饰符)
│   ├── 数值修改
│   ├── 源管理
│   └── 类型管理
└── Effect (效果系统)
    ├── 效果触发
    ├── 条件判断
    └── 动作执行
```

## 核心组件详解

### ItemAssetsCollection - 物品资产集合

ItemAssetsCollection是物品系统的管理中心，负责所有物品类型的注册、实例化和搜索。

#### 主要职责

1. **预制体管理**：管理所有物品类型的预制体
2. **动态物品管理**：支持运行时添加和移除物品类型
3. **物品实例化**：提供同步和异步的物品创建方法
4. **物品搜索**：根据条件搜索符合条件的物品类型

#### 关键方法

```csharp
// 异步实例化物品
Item item = await ItemAssetsCollection.InstantiateAsync(typeID);

// 同步实例化物品
Item item = ItemAssetsCollection.InstantiateSync(typeID);

// 添加动态物品
bool success = ItemAssetsCollection.AddDynamicEntry(customItem);

// 移除动态物品
ItemAssetsCollection.RemoveDynamicEntry(customItem);

// 搜索物品
ItemFilter filter = new ItemFilter();
filter.requireTags = new string[] { "Weapon" };
filter.minQuality = 1;
int[] itemIds = ItemAssetsCollection.Search(filter);
```

#### 使用场景

- 游戏启动时加载所有物品类型
- 运行时添加MOD物品或活动物品
- 根据条件查找特定类型的物品
- 创建物品实例

### Item - 物品核心

Item是物品系统的核心类，所有游戏物品都基于此类。它是一个MonoBehaviour组件，可以附加到GameObject上。

#### 核心属性系统

##### 基础属性

- **TypeID**: 物品的唯一类型标识符
- **DisplayName**: 物品的显示名称（本地化后）
- **Description**: 物品的描述文本（本地化后）
- **Icon**: 物品的图标
- **Value**: 物品的基础价值
- **Quality**: 物品的品质等级

##### 堆叠系统

- **MaxStackCount**: 最大堆叠数量
- **Stackable**: 是否可堆叠（只读属性）
- **StackCount**: 当前堆叠数量

```csharp
// 检查物品是否可堆叠
if (item.Stackable) {
    // 获取和设置堆叠数量
    int currentCount = item.StackCount;
    item.StackCount = Math.Min(currentCount + 1, item.MaxStackCount);
}
```

##### 重量系统

- **UnitSelfWeight**: 单个物品的重量
- **SelfWeight**: 物品自身的总重量（单个重量 × 堆叠数量）
- **TotalWeight**: 物品的总重量（包括子物品和背包内容）

```csharp
// 计算物品总重量
float totalWeight = item.TotalWeight;
Debug.Log($"物品 {item.DisplayName} 总重量: {totalWeight}");

// 重新计算重量（在子物品变化后调用）
item.RecalculateTotalWeight();
```

##### 耐久度系统

- **MaxDurability**: 最大耐久度
- **Durability**: 当前耐久度
- **UseDurability**: 是否使用耐久度系统（只读）
- **Repairable**: 是否可修复（只读）

```csharp
// 检查耐久度
if (item.UseDurability) {
    float durabilityPercent = (item.Durability / item.MaxDurability) * 100f;
    Debug.Log($"耐久度: {durabilityPercent:F1}%");
    
    // 修复物品
    if (item.Repairable && item.Durability < item.MaxDurability) {
        item.Durability = item.MaxDurability;
    }
}
```

##### 标签系统

- **Tags**: 物品的标签集合
- **Sticky**: 是否为粘性物品（不可丢弃或出售）
- **CanBeSold**: 是否可以出售
- **CanDrop**: 是否可以丢弃

```csharp
// 检查物品标签
if (item.Tags.Contains("Weapon")) {
    Debug.Log("这是一个武器");
}

// 检查是否可以出售
if (item.CanBeSold) {
    int sellPrice = item.GetTotalRawValue();
    Debug.Log($"可以出售，价格: {sellPrice}");
}
```

#### 组件系统

Item类包含多个子组件，每个组件负责特定的功能：

##### StatCollection - 统计属性集合

管理物品的各种数值属性，如伤害、防御、攻击速度等。

```csharp
// 获取统计属性
Stat damageStat = item.GetStat("Damage");
if (damageStat != null) {
    float damage = damageStat.Value;
    Debug.Log($"伤害值: {damage}");
}

// 直接获取统计属性值
float defense = item.GetStatValue("Defense");

// 添加修饰符
Modifier damageModifier = new Modifier(10f, ModifierType.Add, this);
item.AddModifier("Damage", damageModifier);
```

##### SlotCollection - 插槽集合

管理物品的插槽，用于装备其他物品。

```csharp
// 获取插槽集合
SlotCollection slots = item.Slots;
if (slots != null) {
    // 遍历所有插槽
    foreach (var slot in slots) {
        if (slot.Content != null) {
            Debug.Log($"插槽 {slot.Key} 中有物品: {slot.Content.DisplayName}");
        }
    }
}
```

##### ModifierDescriptionCollection - 修饰符集合

管理物品的修饰符描述，用于UI显示。

##### Inventory - 背包组件

用于容器类物品，可以存储其他物品。

```csharp
// 获取背包组件
Inventory inventory = item.Inventory;
if (inventory != null) {
    // 添加物品到背包
    Item newItem = GetItem();
    inventory.AddItem(newItem);
    
    // 遍历背包内容
    foreach (var invItem in inventory) {
        Debug.Log($"背包中有物品: {invItem.DisplayName}");
    }
}
```

##### Effect - 效果列表

管理物品的被动效果和触发效果。

```csharp
// 获取效果列表
List<Effect> effects = item.Effects;
if (effects != null && effects.Count > 0) {
    Debug.Log($"物品有 {effects.Count} 个效果");
    
    // 添加新效果
    Effect newEffect = CreateCustomEffect();
    item.AddEffect(newEffect);
}
```

#### 变量系统

Item类提供了灵活的变量系统，允许存储自定义数据：

##### Variables - 运行时变量

用于存储运行时变化的数据，会保存在存档中。

```csharp
// 设置变量
item.SetFloat("CustomValue", 10.5f);
item.SetInt("CustomCount", 5);
item.SetBool("CustomFlag", true);
item.SetString("CustomText", "Hello World");

// 获取变量
float customValue = item.GetFloat("CustomValue", 0f);
int customCount = item.GetInt("CustomCount", 0);
bool customFlag = item.GetBool("CustomFlag", false);
string customText = item.GetString("CustomText", "");
```

##### Constants - 设计时常量

用于存储设计时确定的数据，通常不会在运行时修改。

```csharp
// 获取常量
float maxDurability = item.Constants.GetFloat("MaxDurability", 0f);
string itemCategory = item.Constants.GetString("Category", "");
```

#### 事件系统

Item类提供了丰富的事件系统，用于响应物品的各种状态变化：

##### 基本事件

```csharp
// 监听物品使用
item.onUse += OnItemUsed;
Item.onUseStatic += OnAnyItemUsed;

// 监听物品销毁
item.onDestroy += OnItemDestroyed;

private void OnItemUsed(Item usedItem, object user) {
    Debug.Log($"物品 {usedItem.DisplayName} 被 {user} 使用");
}

private void OnAnyItemUsed(Item usedItem, object user) {
    Debug.Log($"任何物品 {usedItem.DisplayName} 被 {user} 使用");
}

private void OnItemDestroyed(Item destroyedItem) {
    Debug.Log($"物品 {destroyedItem.DisplayName} 已销毁");
}
```

##### 状态变化事件

```csharp
// 监听耐久度变化
item.onDurabilityChanged += OnDurabilityChanged;

// 监听堆叠数量变化
item.onSetStackCount += OnStackCountChanged;

// 监听检查状态变化
item.onInspectionStateChanged += OnInspectionStateChanged;

private void OnDurabilityChanged(Item changedItem) {
    float durabilityPercent = (changedItem.Durability / changedItem.MaxDurability) * 100f;
    Debug.Log($"物品 {changedItem.DisplayName} 耐久度: {durabilityPercent:F1}%");
}
```

##### 关系变化事件

```csharp
// 监听父级变化
item.onParentChanged += OnParentChanged;

// 监听插槽变化
item.onPluggedIntoSlot += OnPluggedIntoSlot;
item.onUnpluggedFromSlot += OnUnpluggedFromSlot;

private void OnParentChanged(Item changedItem) {
    Debug.Log($"物品 {changedItem.DisplayName} 父级关系变化");
}
```

### Inventory - 背包系统

Inventory类负责管理物品的存储和检索，支持容量限制和重量计算。

#### 主要功能

1. **容量管理**：支持最大容量限制
2. **物品存储**：添加、移除、查找物品
3. **自动合并**：自动合并相同类型的可堆叠物品
4. **重量计算**：实时计算背包中所有物品的总重量
5. **事件通知**：内容变化时触发事件

#### 关键属性和方法

```csharp
// 获取背包
Inventory inventory = GetInventory();

// 设置容量
inventory.SetCapacity(100);

// 添加物品
Item newItem = GetItem();
bool added = inventory.AddItem(newItem);

// 移除物品
bool removed = inventory.RemoveItem(newItem);

// 查找物品
Item foundItem = inventory.FindItem(item => item.TypeID == targetTypeID);

// 获取总重量
float totalWeight = inventory.CachedWeight;

// 重新计算重量
inventory.RecalculateWeight();

// 监听内容变化
inventory.onContentChanged += OnInventoryChanged;

private void OnInventoryChanged(Inventory changedInventory, int index) {
    Debug.Log($"背包内容变化，索引: {index}");
}
```

#### 使用场景

- 玩家背包管理
- 容器物品（如箱子、背包）的内容管理
- 商店库存管理
- 战利品容器管理

### Slot - 插槽系统

Slot类用于物品的装备和连接，支持复杂的物品关系。

#### 主要功能

1. **物品装备**：插入和拔出物品
2. **连接管理**：维护物品之间的连接关系
3. **类型限制**：可以限制可插入的物品类型
4. **事件通知**：内容变化时触发事件

#### 关键属性和方法

```csharp
// 获取插槽
Slot slot = GetSlot();

// 插入物品
Item item = GetItem();
bool plugged = slot.Plug(item);

// 拔出物品
slot.Unplug();

// 检查插槽内容
if (slot.Content != null) {
    Debug.Log($"插槽中有物品: {slot.Content.DisplayName}");
}

// 获取插槽所属的物品
Item masterItem = slot.Master;

// 监听插槽变化
slot.onContentChanged += OnSlotChanged;

private void OnSlotChanged(Slot changedSlot) {
    if (changedSlot.Content != null) {
        Debug.Log($"插槽 {changedSlot.Key} 现在有物品: {changedSlot.Content.DisplayName}");
    } else {
        Debug.Log($"插槽 {changedSlot.Key} 已清空");
    }
}
```

#### 使用场景

- 武器装备槽
- 防具装备槽
- 配件插槽（如瞄准镜、弹匣）
- 工具配件槽

### Stat - 统计属性系统

Stat类管理物品的各种数值属性，支持修饰符系统。

#### 主要功能

1. **基础值管理**：存储属性的基础值
2. **修饰符系统**：支持多种类型的修饰符
3. **数值计算**：自动计算最终值
4. **事件通知**：值变化时触发事件

#### 修饰符类型

- **Add**: 加法修饰符，直接加到基础值上
- **Multiply**: 乘法修饰符，与当前值相乘
- **Percentage**: 百分比修饰符，按百分比增加或减少

```csharp
// 获取统计属性
Stat damageStat = item.GetStat("Damage");
if (damageStat != null) {
    // 获取基础值
    float baseValue = damageStat.BaseValue;
    
    // 获取最终值（包含所有修饰符）
    float finalValue = damageStat.Value;
    
    // 添加加法修饰符
    Modifier addModifier = new Modifier(10f, ModifierType.Add, this);
    damageStat.AddModifier(addModifier);
    
    // 添加乘法修饰符
    Modifier mulModifier = new Modifier(1.2f, ModifierType.Multiply, this);
    damageStat.AddModifier(mulModifier);
    
    // 移除修饰符
    damageStat.RemoveModifier(addModifier);
    
    // 移除特定来源的所有修饰符
    int removedCount = damageStat.RemoveAllModifiersFromSource(this);
}
```

#### 使用场景

- 武器伤害、射速、弹匣容量
- 防具防御力、耐久度
- 工具效率、耐久度
- 消耗品效果值、持续时间

### Effect - 效果系统

Effect类管理物品的被动效果和触发效果。

#### 主要功能

1. **效果触发**：根据条件触发效果
2. **动作执行**：执行具体的效果动作
3. **条件判断**：检查效果是否应该激活
4. **生命周期管理**：管理效果的激活和停用

#### 效果类型

- **被动效果**：持续生效的效果
- **触发效果**：满足条件时触发的效果
- **使用效果**：使用物品时触发的效果

```csharp
// 创建效果
GameObject effectObj = new GameObject("CustomEffect");
effectObj.transform.SetParent(item.transform, false);
Effect effect = effectObj.AddComponent<Effect>();

// 设置效果参数
effect.SetItem(item);

// 添加到物品
item.AddEffect(effect);

// 效果会根据物品状态自动激活或停用
// 当物品被装备或耐久度大于0时激活
// 当物品被卸下或耐久度为0时停用
```

#### 使用场景

- 武器附加效果（如火焰伤害、毒素效果）
- 防具防护效果（如伤害减免、元素抗性）
- 消耗品效果（如治疗、增益）
- 工具特殊效果（如采集加成、制作加速）

## 物品关系系统

### 树形结构

物品系统支持树形结构，一个物品可以包含其他物品，形成复杂的组合关系。

```
装备物品（根节点）
├── 插槽1: 武器
│   ├── 插槽1: 弹匣
│   └── 插槽2: 瞄准镜
├── 插槽2: 防具
│   └── 插槽1: 护甲片
└── 背包
    ├── 物品1
    ├── 物品2
    └── 容器
        └── 物品3
```

### 父子关系

每个物品都可以有父级物品或父级背包：

```csharp
// 获取父级物品
Item parentItem = item.ParentItem;
if (parentItem != null) {
    Debug.Log($"父级物品: {parentItem.DisplayName}");
}

// 获取父级对象（可能是Item或Inventory）
UnityEngine.Object parentObj = item.ParentObject;
if (parentObj is Item parent) {
    Debug.Log($"父级是物品: {parent.DisplayName}");
} else if (parentObj is Inventory parentInv) {
    Debug.Log("父级是背包");
}

// 获取物品所在的插槽
Slot slot = item.PluggedIntoSlot;
if (slot != null) {
    Debug.Log($"物品在插槽: {slot.Key}");
}

// 获取物品所在的背包
Inventory inventory = item.InInventory;
if (inventory != null) {
    Debug.Log("物品在背包中");
}
```

### 重量和价值计算

物品的重量和价值是递归计算的，包含所有子物品：

```csharp
// 获取物品总重量（包含所有子物品）
float totalWeight = item.TotalWeight;

// 获取物品总价值（考虑耐久度、堆叠数量和子物品）
int totalValue = item.GetTotalRawValue();

// 重新计算重量（在子物品变化后）
item.RecalculateTotalWeight();
```

## 物品生命周期

### 创建阶段

1. **实例化**：通过ItemAssetsCollection创建物品实例
2. **初始化**：调用Initialize方法初始化组件
3. **配置**：设置物品属性和变量
4. **激活**：将物品添加到游戏世界

```csharp
// 创建物品
Item item = ItemAssetsCollection.InstantiateSync(itemTypeId);

if (item != null) {
    // 初始化（通常在Awake中自动调用）
    item.Initialize();
    
    // 配置物品
    item.StackCount = 5;
    item.Durability = item.MaxDurability;
    
    // 添加到游戏世界
    playerInventory.AddItem(item);
}
```

### 使用阶段

1. **装备**：将物品插入插槽或添加到背包
2. **使用**：调用Use方法使用物品
3. **效果激活**：根据物品状态激活或停用效果
4. **状态变化**：响应各种状态变化事件

```csharp
// 装备物品
slot.Plug(item);

// 使用物品
if (item.IsUsable(player)) {
    item.Use(player);
}

// 监听状态变化
item.onDurabilityChanged += OnDurabilityChanged;
item.onParentChanged += OnParentChanged;
```

### 销毁阶段

1. **分离**：从父级（插槽或背包）中分离
2. **清理**：释放资源和取消事件监听
3. **销毁**：销毁GameObject和相关组件

```csharp
// 分离物品
item.Detach();

// 销毁物品
item.DestroyTree();

// 监听销毁事件
item.onDestroy += OnItemDestroyed;
```

## 物品系统扩展

### 动态物品

支持运行时添加新的物品类型：

```csharp
// 创建自定义物品
GameObject itemObj = new GameObject("CustomItem");
Item customItem = itemObj.AddComponent<Item>();

// 配置物品
customItem.TypeID = customTypeId;
customItem.DisplayNameRaw = "CustomWeapon";
customItem.Value = 100;
customItem.MaxStackCount = 1;

// 添加到物品系统
bool success = ItemAssetsCollection.AddDynamicEntry(customItem);
if (success) {
    Debug.Log("自定义物品添加成功");
}
```

### 自定义组件

可以为物品添加自定义组件，扩展物品功能：

```csharp
// 创建自定义组件
public class CustomItemComponent : MonoBehaviour {
    public Item item;
    
    void Start() {
        item = GetComponent<Item>();
        // 初始化自定义逻辑
    }
    
    public void DoCustomAction() {
        // 自定义行为
    }
}

// 添加到物品
CustomItemComponent customComp = item.gameObject.AddComponent<CustomItemComponent>();
```

### 自定义效果

创建自定义效果类，实现特殊效果逻辑：

```csharp
public class FireDamageEffect : Effect {
    public float fireDamage = 5f;
    
    protected override void OnEnable() {
        base.OnEnable();
        // 效果激活时的逻辑
    }
    
    protected override void OnDisable() {
        base.OnDisable();
        // 效果停用时的逻辑
    }
    
    void Update() {
        // 每帧更新的逻辑
        if (Item != null && Item.ActiveAgent != null) {
            // 应用火焰伤害
        }
    }
}
```

## 性能优化

### 重量缓存

物品系统使用缓存机制优化重量计算：

```csharp
// 获取缓存的重量（快速）
float cachedWeight = item.TotalWeight;

// 强制重新计算（在子物品变化后）
item.RecalculateTotalWeight();
```

### 事件优化

合理使用事件系统，避免不必要的监听：

```csharp
void OnEnable() {
    // 只在需要时监听事件
    if (shouldListenToEvents) {
        Item.onUseStatic += OnItemUsed;
    }
}

void OnDisable() {
    // 及时取消监听，避免内存泄漏
    Item.onUseStatic -= OnItemUsed;
}
```

### 对象池

对于频繁创建和销毁的物品，使用对象池优化性能：

```csharp
// 从对象池获取物品
Item item = ItemPool.Instance.Get(itemTypeId);

// 归还到对象池
ItemPool.Instance.Return(item);
```

## 常见问题和解决方案

### 物品不显示

**问题**：创建物品后不显示在UI中

**解决方案**：
1. 检查物品是否正确添加到背包或插槽
2. 确认UI是否正确监听背包变化事件
3. 验证物品图标是否正确设置

```csharp
// 确保物品添加到背包
bool added = inventory.AddItem(item);
if (!added) {
    Debug.LogError("物品添加失败");
}

// 监听背包变化
inventory.onContentChanged += UpdateUI;
```

### 物品效果不生效

**问题**：物品效果没有按预期工作

**解决方案**：
1. 检查物品是否正确装备或激活
2. 确认效果条件是否满足
3. 验证效果组件是否正确添加

```csharp
// 检查物品状态
bool isActive = item.PluggedIntoSlot != null || item.IsCharacter;
bool hasDurability = !item.UseDurability || item.Durability > 0;

if (isActive && hasDurability) {
    Debug.Log("物品应该处于激活状态");
}
```

### 物品重量计算错误

**问题**：物品重量计算不正确

**解决方案**：
1. 调用RecalculateTotalWeight强制重新计算
2. 检查子物品是否正确设置父级关系
3. 确认重量缓存是否正确更新

```csharp
// 强制重新计算重量
float totalWeight = item.RecalculateTotalWeight();
Debug.Log($"重新计算的总重量: {totalWeight}");
```

### 物品保存和加载问题

**问题**：物品状态在存档中不正确

**解决方案**：
1. 确保自定义变量正确设置
2. 检查动态物品是否正确注册
3. 验证物品ID是否唯一

```csharp
// 设置自定义变量（会保存到存档）
item.SetFloat("CustomValue", 10.5f);

// 设置常量（设计时数据）
item.Constants.SetFloat("MaxDurability", 100f);
```

## 总结

物品系统是《逃离鸭科夫》的核心系统，提供了灵活、强大的物品管理功能。通过组件化设计、树形结构和事件系统，支持复杂的物品关系和动态行为。合理使用物品系统的各种功能，可以实现丰富的游戏玩法和交互体验。

### 最佳实践

1. **合理使用标签系统**：通过标签分类物品，便于管理和过滤
2. **优化事件监听**：及时添加和移除事件监听，避免内存泄漏
3. **使用变量系统**：利用Variables和Constants存储自定义数据
4. **考虑性能影响**：对于频繁操作，使用缓存和对象池优化
5. **模块化设计**：将复杂功能分解为多个组件，提高可维护性

通过遵循这些最佳实践，可以充分发挥物品系统的潜力，创建出丰富多样的游戏内容。