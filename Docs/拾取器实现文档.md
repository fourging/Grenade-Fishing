# 球形范围检测拾取器实现文档

## 概述
本文档描述了如何实现一个基于球形范围检测的物品拾取器，当玩家按下按键后执行一次周围掉落物品的拾取操作。

## 核心实现步骤

### 1. 按键检测
在Update方法中检测玩家按键输入：
```csharp
if (Input.GetKeyDown(KeyCode.Y)) // 替换Y为你想要的按键
{
    ExecutePickup();
}
```

### 2. 球形范围检测实现

#### 2.1 计算检测中心点
```csharp
Vector3 detectionCenter = character.transform.position + Vector3.up * 0.5f + character.CurrentAimDirection * 0.2f;
```

#### 2.2 设置检测参数
```csharp
float detectionRadius = 0.35f;
int interactableLayer = LayerMask.NameToLayer("Interactable");
int layerMask = (interactableLayer >= 0) ? (1 << interactableLayer) : (-1);
```

#### 2.3 执行物理检测
```csharp
Collider[] detectedColliders = new Collider[8];
int hitCount = Physics.OverlapSphereNonAlloc(detectionCenter, detectionRadius, detectedColliders, layerMask, QueryTriggerInteraction.Collide);
```

### 3. 遍历检测到的物体

#### 3.1 查找最近的拾取物品
```csharp
float closestDistance = 999f;
InteractablePickup closestPickup = null;

for (int i = 0; i < hitCount; i++)
{
    Collider collider = detectedColliders[i];
    if (collider == null)
    {
        continue;
    }
    
    InteractablePickup pickup = collider.GetComponent<InteractablePickup>();
    if (pickup != null)
    {
        float distance = Vector3.Distance(character.transform.position, pickup.transform.position);
        if (distance < closestDistance)
        {
            closestDistance = distance;
            closestPickup = pickup;
        }
    }
}
```

### 4. 单个掉落物品拾取逻辑

#### 4.1 获取物品信息
```csharp
if (closestPickup != null)
{
    DuckovItemAgent itemAgent = closestPickup.ItemAgent;
    if (itemAgent != null)
    {
        Item item = ((ItemAgent)itemAgent).Item;
        if (item != null)
        {
            // 执行拾取逻辑
        }
    }
}
```

#### 4.2 执行拾取操作
```csharp
bool pickupSuccess = character.PickupItem(item);
if (pickupSuccess)
{
    // 显示拾取信息
    string itemName = item.DisplayName;
    if (string.IsNullOrEmpty(itemName))
    {
        itemName = item.DisplayNameRaw;
    }
    if (string.IsNullOrEmpty(itemName))
    {
        itemName = "物品";
    }
    
    int stackCount = 1;
    try
    {
        int itemCount = item.StackCount;
        if (itemCount > 0)
        {
            stackCount = itemCount;
        }
    }
    catch
    {
    }
    
    string pickupMessage = (stackCount > 1) ? $"拾取：{itemName}×{stackCount}" : ("拾取：" + itemName);
    character.PopText(pickupMessage, -1f);
}
```

## 完整的拾取执行方法

```csharp
private void ExecutePickup()
{
    // 前置检查
    if (character == null || !character.IsMainCharacter)
    {
        return;
    }
    
    if (!InputManager.InputActived)
    {
        return;
    }
    
    if (character.CurrentAction != null && character.CurrentAction.Running)
    {
        return;
    }
    
    // 球形范围检测
    Vector3 detectionCenter = character.transform.position + Vector3.up * 0.5f + character.CurrentAimDirection * 0.2f;
    float detectionRadius = 0.35f;
    int interactableLayer = LayerMask.NameToLayer("Interactable");
    int layerMask = (interactableLayer >= 0) ? (1 << interactableLayer) : (-1);
    
    Collider[] detectedColliders = new Collider[8];
    int hitCount = Physics.OverlapSphereNonAlloc(detectionCenter, detectionRadius, detectedColliders, layerMask, QueryTriggerInteraction.Collide);
    
    // 查找最近的拾取物品
    float closestDistance = 999f;
    InteractablePickup closestPickup = null;
    
    for (int i = 0; i < hitCount; i++)
    {
        Collider collider = detectedColliders[i];
        if (collider == null)
        {
            continue;
        }
        
        InteractablePickup pickup = collider.GetComponent<InteractablePickup>();
        if (pickup != null)
        {
            float distance = Vector3.Distance(character.transform.position, pickup.transform.position);
            if (distance < closestDistance)
            {
                closestDistance = distance;
                closestPickup = pickup;
            }
        }
    }
    
    // 执行拾取
    if (closestPickup != null)
    {
        DuckovItemAgent itemAgent = closestPickup.ItemAgent;
        if (itemAgent != null)
        {
            Item item = ((ItemAgent)itemAgent).Item;
            if (item != null)
            {
                bool pickupSuccess = character.PickupItem(item);
                if (pickupSuccess)
                {
                    // 显示拾取信息
                    string itemName = item.DisplayName;
                    if (string.IsNullOrEmpty(itemName))
                    {
                        itemName = item.DisplayNameRaw;
                    }
                    if (string.IsNullOrEmpty(itemName))
                    {
                        itemName = "物品";
                    }
                    
                    int stackCount = 1;
                    try
                    {
                        int itemCount = item.StackCount;
                        if (itemCount > 0)
                        {
                            stackCount = itemCount;
                        }
                    }
                    catch
                    {
                    }
                    
                    string pickupMessage = (stackCount > 1) ? $"拾取：{itemName}×{stackCount}" : ("拾取：" + itemName);
                    character.PopText(pickupMessage, -1f);
                }
            }
        }
    }
}
```

## 关键参数说明

- **检测半径**: 0.35单位
- **检测中心**: 角色位置 + 向上0.5单位 + 瞄准方向0.2单位
- **最大检测数量**: 8个碰撞体
- **检测层级**: Interactable层
- **触发器交互**: QueryTriggerInteraction.Collide

## 依赖组件

- `CharacterMainControl`: 角色主控制器
- `InteractablePickup`: 可拾取物品组件
- `DuckovItemAgent`: 物品代理组件
- `Item`: 物品数据
- `Physics`: 物理检测系统
- `Vector3`: 三维向量
- `Collider`: 碰撞体组件

## 注意事项

1. 所有方法调用都基于原项目中使用的API，没有使用反射
2. 检测范围固定为0.35单位，可根据需要调整
3. 只拾取单个最近的物品，不是批量拾取
4. 包含完整的前置条件检查和错误处理
5. 拾取成功后会显示物品信息