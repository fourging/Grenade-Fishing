# 获取爆炸投掷物世界坐标指南

本文档介绍如何获取游戏中爆炸投掷物（如手雷）最终爆炸位置的世界坐标。

## 概述

在这个游戏中，爆炸投掷物（如手雷）的爆炸位置可以通过多种方式获取。最直接的方法是通过订阅 `Grenade` 类的 `onExplodeEvent` 事件，在爆炸发生时获取投掷物的位置。

## 方法一：通过 onExplodeEvent 事件获取爆炸位置

### 基本用法

`Grenade` 类提供了一个 `onExplodeEvent` 事件，可以在爆炸发生时触发。你可以订阅这个事件来获取爆炸位置：

```csharp
// 获取手雷实例
Grenade grenade = // 获取手雷实例的方法

// 订阅爆炸事件
grenade.onExplodeEvent.AddListener(() => {
    // 在事件触发时，手雷的 transform.position 就是爆炸位置
    Vector3 explosionPosition = grenade.transform.position;
    // 使用爆炸位置...
    Debug.Log($"爆炸位置: {explosionPosition}");
});
```

### 完整示例

```csharp
using UnityEngine;

public class ExplosionTracker : MonoBehaviour
{
    private Grenade trackedGrenade;
    
    void Start()
    {
        // 假设我们有一个方法来获取或创建手雷实例
        trackedGrenade = GetGrenadeInstance();
        
        if (trackedGrenade != null)
        {
            // 订阅爆炸事件
            trackedGrenade.onExplodeEvent.AddListener(OnGrenadeExploded);
        }
    }
    
    private void OnGrenadeExploded()
    {
        // 获取爆炸位置
        Vector3 explosionPosition = trackedGrenade.transform.position;
        
        // 处理爆炸位置
        Debug.Log($"手雷在位置 {explosionPosition} 爆炸");
        
        // 可以在这里执行其他逻辑，如：
        // - 创建特效
        // - 计算伤害范围
        // - 记录爆炸位置用于分析
        CreateExplosionEffect(explosionPosition);
    }
    
    private void CreateExplosionEffect(Vector3 position)
    {
        // 在爆炸位置创建特效
        // GameObject explosionEffect = Instantiate(explosionPrefab, position, Quaternion.identity);
    }
    
    private Grenade GetGrenadeInstance()
    {
        // 这里应该是获取手雷实例的实际逻辑
        // 可能是从技能系统、物品系统或其他地方获取
        return null;
    }
}
```

## 方法二：通过 ExplosionManager 获取爆炸位置

如果你无法直接访问 `Grenade` 实例，但可以访问 `ExplosionManager`，你可以通过监听爆炸事件来获取位置：

```csharp
using UnityEngine;

public class ExplosionMonitor : MonoBehaviour
{
    private ExplosionManager explosionManager;
    
    void Start()
    {
        // 获取爆炸管理器实例
        explosionManager = LevelManager.Instance.ExplosionManager;
        
        // 注意：原始的 ExplosionManager 没有提供事件，所以需要使用其他方法
        // 这里展示的是概念性代码，实际实现可能需要修改 ExplosionManager
    }
    
    // 如果可以修改 ExplosionManager，可以添加事件：
    // public event Action<Vector3> OnExplosionCreated;
    
    // 然后在 CreateExplosion 方法中触发事件：
    // public void CreateExplosion(Vector3 center, float radius, DamageInfo dmgInfo, ...)
    // {
    //     // 原有逻辑...
    //     
    //     // 触发事件
    //     OnExplosionCreated?.Invoke(center);
    // }
}
```

## 方法三：通过自定义爆炸事件系统

如果需要更灵活的爆炸位置追踪，可以实现一个自定义的爆炸事件系统：

```csharp
using UnityEngine;
using System;

public class ExplosionEventSystem : MonoBehaviour
{
    public static ExplosionEventSystem Instance { get; private set; }
    
    public event Action<Vector3, float> OnExplosion;
    
    void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
        }
        else
        {
            Destroy(gameObject);
        }
    }
    
    public void NotifyExplosion(Vector3 position, float radius)
    {
        OnExplosion?.Invoke(position, radius);
    }
}

// 在 Grenade 类的 Explode 方法中添加：
// ExplosionEventSystem.Instance.NotifyExplosion(base.transform.position, this.damageRange);

// 使用示例：
public class ExplosionListener : MonoBehaviour
{
    void Start()
    {
        ExplosionEventSystem.Instance.OnExplosion += HandleExplosion;
    }
    
    private void HandleExplosion(Vector3 position, float radius)
    {
        Debug.Log($"爆炸位置: {position}, 半径: {radius}");
    }
}
```

## 方法四：通过物理检测获取爆炸位置

如果你无法访问爆炸事件，但需要检测爆炸，可以使用物理检测：

```csharp
using UnityEngine;

public class ExplosionDetector : MonoBehaviour
{
    public float detectionRadius = 50f;
    public LayerMask explosionLayer;
    
    void Update()
    {
        // 检测范围内的爆炸效果
        Collider[] hitColliders = Physics.OverlapSphere(transform.position, detectionRadius, explosionLayer);
        
        foreach (var hitCollider in hitColliders)
        {
            // 检查是否是爆炸特效
            if (hitCollider.CompareTag("ExplosionEffect"))
            {
                Vector3 explosionPosition = hitCollider.transform.position;
                Debug.Log($"检测到爆炸在位置: {explosionPosition}");
            }
        }
    }
}
```

## 获取手雷实例的方法

要使用上述方法，首先需要获取 `Grenade` 实例。以下是几种常见的方法：

### 1. 从技能系统获取

```csharp
public Grenade GetGrenadeFromSkill()
{
    // 假设有一个技能管理器
    Skill_Grenade grenadeSkill = SkillManager.Instance.GetSkill<Skill_Grenade>();
    
    if (grenadeSkill != null && grenadeSkill.grenadePfb != null)
    {
        // 创建手雷实例
        return Instantiate(grenadeSkill.grenadePfb);
    }
    
    return null;
}
```

### 2. 从场景中查找

```csharp
public Grenade FindGrenadeInScene()
{
    // 查找场景中的所有手雷
    Grenade[] grenades = FindObjectsOfType<Grenade>();
    
    if (grenades.Length > 0)
    {
        // 返回第一个找到的手雷
        return grenades[0];
    }
    
    return null;
}
```

### 3. 通过事件监听创建

```csharp
public class GrenadeSpawnerListener : MonoBehaviour
{
    private List<Grenade> activeGrenades = new List<Grenade>();
    
    void Start()
    {
        // 监听手雷生成事件（如果系统提供）
        // GrenadeSpawner.OnGrenadeSpawned += HandleGrenadeSpawned;
    }
    
    private void HandleGrenadeSpawned(Grenade grenade)
    {
        activeGrenades.Add(grenade);
        
        // 订阅爆炸事件
        grenade.onExplodeEvent.AddListener(() => {
            Vector3 explosionPosition = grenade.transform.position;
            Debug.Log($"手雷爆炸位置: {explosionPosition}");
            
            // 从列表中移除
            activeGrenades.Remove(grenade);
        });
    }
}
```

## 注意事项

1. **生命周期管理**：确保在不再需要时取消事件订阅，避免内存泄漏：
   ```csharp
   void OnDestroy()
   {
       if (trackedGrenade != null)
       {
           trackedGrenade.onExplodeEvent.RemoveListener(OnGrenadeExploded);
       }
   }
   ```

2. **多手雷处理**：如果场景中可能有多个手雷，需要为每个手雷单独处理事件：
   ```csharp
   Dictionary<Grenade, UnityAction> grenadeListeners = new Dictionary<Grenade, UnityAction>();
   
   void TrackGrenade(Grenade grenade)
   {
       UnityAction listener = () => OnGrenadeExploded(grenade);
       grenadeListeners[grenade] = listener;
       grenade.onExplodeEvent.AddListener(listener);
   }
   ```

3. **坐标系统**：确保你理解游戏的坐标系统，`transform.position` 返回的是世界坐标。

4. **性能考虑**：频繁的爆炸检测可能会影响性能，特别是在大型场景中。

## 完整示例项目

以下是一个完整的示例，展示如何创建一个系统来追踪所有手雷的爆炸位置：

```csharp
using UnityEngine;
using System.Collections.Generic;
using System;

public class ExplosionPositionTracker : MonoBehaviour
{
    public static ExplosionPositionTracker Instance { get; private set; }
    
    // 存储所有活跃的手雷
    private Dictionary<Grenade, DateTime> activeGrenades = new Dictionary<Grenade, DateTime>();
    
    // 爆炸位置历史记录
    public struct ExplosionRecord
    {
        public Vector3 position;
        public DateTime timestamp;
        public float damageRange;
    }
    
    private List<ExplosionRecord> explosionHistory = new List<ExplosionRecord>();
    
    public event Action<ExplosionRecord> OnExplosionRecorded;
    
    void Awake()
    {
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject);
        }
        else
        {
            Destroy(gameObject);
        }
    }
    
    void Update()
    {
        // 定期清理已销毁的手雷引用
        CleanupDestroyedGrenades();
    }
    
    // 注册新手雷
    public void RegisterGrenade(Grenade grenade)
    {
        if (grenade != null && !activeGrenades.ContainsKey(grenade))
        {
            activeGrenades[grenade] = DateTime.Now;
            
            // 订阅爆炸事件
            grenade.onExplodeEvent.AddListener(() => OnGrenadeExploded(grenade));
        }
    }
    
    private void OnGrenadeExploded(Grenade grenade)
    {
        if (activeGrenades.ContainsKey(grenade))
        {
            // 记录爆炸位置
            ExplosionRecord record = new ExplosionRecord
            {
                position = grenade.transform.position,
                timestamp = DateTime.Now,
                damageRange = grenade.damageRange
            };
            
            explosionHistory.Add(record);
            
            // 触发事件
            OnExplosionRecorded?.Invoke(record);
            
            // 从活跃列表中移除
            activeGrenades.Remove(grenade);
            
            Debug.Log($"记录爆炸位置: {record.position}, 伤害范围: {record.damageRange}");
        }
    }
    
    private void CleanupDestroyedGrenades()
    {
        List<Grenade> toRemove = new List<Grenade>();
        
        foreach (var kvp in activeGrenades)
        {
            if (kvp.Key == null)
            {
                toRemove.Add(kvp.Key);
            }
        }
        
        foreach (var grenade in toRemove)
        {
            activeGrenades.Remove(grenade);
        }
    }
    
    // 获取最近的爆炸记录
    public List<ExplosionRecord> GetRecentExplosions(int count = 10)
    {
        int startIndex = Mathf.Max(0, explosionHistory.Count - count);
        return explosionHistory.GetRange(startIndex, explosionHistory.Count - startIndex);
    }
    
    // 获取指定范围内的爆炸记录
    public List<ExplosionRecord> GetExplosionsInRange(Vector3 center, float radius)
    {
        List<ExplosionRecord> result = new List<ExplosionRecord>();
        
        foreach (var record in explosionHistory)
        {
            if (Vector3.Distance(center, record.position) <= radius)
            {
                result.Add(record);
            }
        }
        
        return result;
    }
}

// 使用示例：
public class ExplosionAnalyzer : MonoBehaviour
{
    void Start()
    {
        // 订阅爆炸事件
        ExplosionPositionTracker.Instance.OnExplosionRecorded += AnalyzeExplosion;
    }
    
    private void AnalyzeExplosion(ExplosionPositionTracker.ExplosionRecord record)
    {
        // 分析爆炸位置
        Debug.Log($"分析爆炸: 位置={record.position}, 时间={record.timestamp}");
        
        // 可以在这里添加更多分析逻辑，如：
        // - 计算与玩家的距离
        // - 检查是否在特定区域内
        // - 统计爆炸频率
    }
    
    void Update()
    {
        // 示例：每5秒输出最近的爆炸统计
        if (Time.time % 5f < Time.deltaTime)
        {
            var recentExplosions = ExplosionPositionTracker.Instance.GetRecentExplosions(5);
            Debug.Log($"最近5秒内有 {recentExplosions.Count} 次爆炸");
        }
    }
}
```

## 总结

获取爆炸投掷物的世界坐标主要通过以下几种方式：

1. **推荐方法**：订阅 `Grenade.onExplodeEvent` 事件，在事件触发时获取 `grenade.transform.position`
2. **替代方法**：通过 `ExplosionManager.CreateExplosion` 方法（需要修改代码添加事件）
3. **自定义方法**：实现自定义的爆炸事件系统
4. **检测方法**：通过物理检测爆炸特效

选择哪种方法取决于你的具体需求和能够访问的代码部分。对于大多数情况，第一种方法是最简单和最直接的。